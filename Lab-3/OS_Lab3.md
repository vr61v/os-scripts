# Лабораторная работа №3.
## Управление процессами в ОС Linux.

### Script 1
Создайте и однократно выполните скрипт (в этом скрипте нельзя использовать условный оператор и
операторы проверки свойств и значений), который будет пытаться создать директорию test в
домашней директории. Если создание директории пройдет успешно, скрипт выведет в файл ~/report
сообщение вида "catalog test was created successfully" и создаст в директории test
файл с именем Дата_Время_Запуска_Скрипта. Затем независимо от результатов предыдущего шага
скрипт должен опросить с помощью команды ping хост www.net_nikogo.ru и, если этот хост
недоступен, дописать сообщение об ошибке в файл ~/report. Сообщение об ошибке должно
начинаться с текущей Дата_Время, а затем содержать через пробел произвольный текст сообщения об
ошибке.
```
#!/bin/bash
date=$(date "+%d.%m.%y_%H:%M:%S")
message="catalog test was created successfuly"
error="$date error: www.net_nikogo.ru is unavailable"
mkdir ~/test && echo $message >> ~/report && touch ~/test/$date.tmp
ping www.net_nikogo.ru || echo $error >> ~/report
```


### Script 2
Задайте еще один однократный запуск скрипта из пункта 1 через 2 минуты. Консоль после этого должна
оставаться свободной. Выполнив отдельную команду организуйте слежение за файлом ~/report и
выведите на консоль новые строки из этого файла, как только они появятся.
```
#!/bin/bash
at now+2minutes -f script1.sh
tail -f ~/report
```


### Script 3
Задайте запуск скрипта из пункта 1 в каждую пятую минут каждого часа в день недели, в который вы
будете выполнять работу.
```
#!/bin/bash
echo "*/5 * * * 1 script1.sh" | crontab
```

### Script 4
Создайте три фоновых процесса, выполняющих одинаковый бесконечный цикл вычисления (например,
перемножение двух чисел). После запуска процессов должна сохраниться возможность использовать
виртуальную консоль, с которой их запустили. Используя команду top, проанализируйте процент
использования ресурсов процессора этими процессами. Создайте скрипт, который будет в
автоматическом режиме обеспечивать, чтобы тот процесс, который был запущен первым, использовал
ресурс процессора не более чем на 10%. Послав сигнал, завершите работу процесса, запущенного
третьим. Проверьте, что созданный скрипт по-прежнему удерживает потребление ресурсов процессора
первым процессом в заданном диапазоне.
1. Бесконечный цикл x+=1
```
#!/bin/bash
echo $$ > $1
x=1
while true; do
  x=$(($x + 1))
done
```
2. Запуск процессов
```
#!/bin/bash
bash script4_while.sh&pid1=$!
bash script4_while.sh&pid2=$!
bash script4_while.sh&pid3=$!
while true; do
  cpu=$(ps -p $pid1 -o pcpu | tail -n 1)
  if (( $(echo "$cpu > 10.0" | bc -l) )); then
    ni=$(ps -p $pid1 -o ni | tail -n 1)
    if [ $ni -le 19 ]; 
      then ni=$(($ni+1))
      renice -n $ni -p $pid1
    fi
  fi
done
```

### Script 5
Создайте пару скриптов: генератор и обработчик. Процесс «Генератор» передает информацию процессу
«Обработчик» с помощью именованного канала. Процесс «Обработчик» должен осуществлять
следующую обработку переданных строк: если строка содержит единственный символ «+», то процесс
обработчик переключает режим на «сложение» и ждет ввода численных данных. Если строка содержит
единственный символ «*», то обработчик переключает режим на «умножение» и ждет ввода численных
данных. Если строка содержит целое число, то обработчик осуществляет текущую активную операцию
(выбранный режим) над текущим значением вычисляемой переменной и считанным значением
(например, складывает или перемножает результат предыдущего вычисления со считанным числом). При
запуске скрипта режим устанавливается в «сложение», а вычисляемая переменная приравнивается к 1. В
случае получения строки QUIT скрипт «Обработчик» выдает сообщение о плановой остановке и оба
скрипта завершают работу. В случае получения любых других значений строки оба скрипта завершают
работу с сообщением об ошибке входных данных.
1. «Генератор»
```
#!/bin/bash
while true; do
  read line
  echo "$line" >> "script5_infile"
done
```
2. «Обработчик»
```
#!/bin/bash
result=1
operation="+"
(tail -f "script5_infile") | while true; do
  read line
  case $line in
    "+") operation="+" ;;
    "*") operation="*" ;;
    "=") echo "result: $result" >> "script5_outfile" ;;
    [[:digit:]]*)
      if [ "$operation" = "+" ]; then let result=$result+$line; fi
      if [ "$operation" = "*" ]; then let result=$result\*$line; fi
    ;;
    "QUIT")
      echo "exit" >> "script5_outfile"
      killall tail
      exit
    ;;
  esac
done
```

### Script 6
Создайте пару скриптов: генератор и обработчик. Процесс «Генератор» считывает с консоли строки в
бесконечном цикле. Если считанная строка содержит единственный символ «+», он посылает процессу
«Обработчик» сигнал USR1. Если строка содержит единственный символ «*», генератор посылает
обработчику сигнал USR2. Если строка содержит слово TERM, генератор посылает обработчику сигнал
SIGTERM и завершает свою работу. Другие значения входных строк игнорируются. Обработчик
добавляет 2 или умножает на 2 текущее значение обрабатываемого числа (начальное значение принять на
единицу) в зависимости от полученного пользовательского сигнала и выводит результат на экран.
Вычисление и вывод производятся один раз в секунду. Получив сигнал SIGTERM, «Обработчик»
завершает свою работу, выведя сообщения о завершении работы по сигналу от другого процесса.
1. «Генератор»
```
#!/bin/bash
while true; do
  read line
  case $line in
    "+") kill -USR1 $(cat .pid) ;;
    "*") kill -USR2 $(cat .pid) ;;
    "TREM") kill -SIGTREM $(cat .pid) ;;
  esac
done
```

2. «Обработчик»
```
#!/bin/bash
echo $$ > .pid
val=1
mode=""
usr1() { mode="sum"; }
usr2() { mode="mult"; }
sigtrem() { mode="sigtrem"; exit; } 
trap 'usr1' USR1
trap 'usr2' USR2
trap 'sigtrem' SIGTREM
while true; do
  case $mode in
    "sum") let val=$val+2 ;;
    "mult") let val=$val*2 ;;
  esac
  echo $val
  sleep 1
done
```

### Script 7
Создайте пару скриптов: генератор и обработчик. Процесс «Генератор» считывает с консоли строки в
бесконечном цикле, в котором он посылает процессу «Обработчик» строки из 5 символов. Если строка 
частично совпадает с загаданной в «Обработчик», то процесс выводит места совпадения(11111 и 12311 
совпадают в 034). Если же строка полностью совпадает с загаданной, то обработчик выводит количество
попыток и завершает работу.
1. «Генератор»
```
#!/bin/bash
while true; do
  read line
  echo "$line" >> "script7_infile"
done
rm "script7_infile"
```

2. «Обработчик»
```
#!/bin/bash
word=$(shuf -i 10000-100000 -n 1)
try=0
echo $word
(tail -f "script7_infile") | while true; do
  read line
  result=""
  for i in 0 1 2 3 4; do
    if [ "${line:$i:1}" == "${word:$i:1}" ]; then 
      result="$result$i"
    fi
  done
  echo "result: $result"
  
  let try=$try+1
  if [ "$result" == "01234" ]; then echo "try: $try"; exit; fi
done
```